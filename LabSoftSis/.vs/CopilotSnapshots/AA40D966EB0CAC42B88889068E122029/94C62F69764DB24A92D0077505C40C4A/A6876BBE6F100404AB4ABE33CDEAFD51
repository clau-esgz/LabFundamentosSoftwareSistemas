using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using System.Text;

namespace laboratorioPractica3
{
    /// <summary>
    /// Analizador semántico para programas SIC/XE
    /// Verifica reglas semánticas más allá de la sintaxis
    /// </summary>
    public class SICXESemanticAnalyzer : SICXEBaseListener
    {
        private readonly HashSet<string> _definedLabels = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        private readonly List<SICXEError> _errors = new List<SICXEError>();
        private readonly List<TokenInfo> _tokens = new List<TokenInfo>();
        
        // Instrucciones que no requieren operandos
        private static readonly HashSet<string> NoOperandInstructions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "FIX", "FLOAT", "HIO", "NORM", "SIO", "TIO", "RSUB"
        };

        // Instrucciones que requieren exactamente 2 registros
        private static readonly HashSet<string> TwoRegisterInstructions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "ADDR", "COMPR", "DIVR", "MULR", "RMO", "SUBR"
        };

        // Instrucciones que requieren 1 registro
        private static readonly HashSet<string> OneRegisterInstructions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "CLEAR", "TIXR"
        };

        // Instrucciones que requieren registro y número
        private static readonly HashSet<string> RegisterNumberInstructions = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "SHIFTL", "SHIFTR", "SVC"
        };

        // Directivas que requieren operando
        private static readonly HashSet<string> RequiredOperandDirectives = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "START", "END", "BYTE", "WORD", "RESB", "RESW", "BASE", "EQU", "ORG", "USE", "EXTDEF", "EXTREF"
        };

        // Directivas que no requieren operando
        private static readonly HashSet<string> NoOperandDirectives = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "NOBASE", "LTORG", "CSECT"
        };

        // Registros válidos de SIC/XE
        private static readonly HashSet<string> ValidRegisters = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "A", "X", "L", "B", "S", "T", "F", "PC", "SW"
        };

        public IReadOnlyList<SICXEError> Errors => _errors;
        public IReadOnlyList<TokenInfo> Tokens => _tokens;

        /// <summary>
        /// Procesa los tokens del lexer para el reporte
        /// </summary>
        public void ProcessTokens(CommonTokenStream tokenStream, SICXELexer lexer)
        {
            tokenStream.Fill();
            foreach (var token in tokenStream.GetTokens())
            {
                if (token.Type != SICXELexer.Eof && token.Type != SICXELexer.WS)
                {
                    string tokenName = lexer.Vocabulary.GetSymbolicName(token.Type) ?? "UNKNOWN";
                    _tokens.Add(new TokenInfo(
                        token.Line,
                        token.Column,
                        token.Text,
                        tokenName,
                        token.Type
                    ));
                }
            }
        }

        /// <summary>
        /// Verifica la etiqueta en cada statement
        /// </summary>
        public override void EnterStatement(SICXEParser.StatementContext context)
        {
            var labelContext = context.label();
            if (labelContext != null)
            {
                string labelText = labelContext.GetText();
                int line = labelContext.Start.Line;
                int column = labelContext.Start.Column;

                // Verificar longitud máxima de 6 caracteres
                if (labelText.Length > 6)
                {
                    _errors.Add(new SICXEError(line, column,
                        $"Etiqueta '{labelText}' excede el máximo de 6 caracteres (tiene {labelText.Length})",
                        SICXEErrorType.Semantico));
                }

                // Verificar que inicia con letra (ya lo hace la gramática, pero verificamos)
                if (!char.IsLetter(labelText[0]))
                {
                    _errors.Add(new SICXEError(line, column,
                        $"Etiqueta '{labelText}' debe iniciar con una letra",
                        SICXEErrorType.Semantico));
                }

                // Verificar etiquetas duplicadas
                if (_definedLabels.Contains(labelText))
                {
                    _errors.Add(new SICXEError(line, column,
                        $"Etiqueta duplicada: '{labelText}'",
                        SICXEErrorType.Semantico));
                }
                else
                {
                    _definedLabels.Add(labelText);
                }
            }
        }

        /// <summary>
        /// Verifica la operación y sus operandos
        /// </summary>
        public override void ExitStatement(SICXEParser.StatementContext context)
        {
            var operationContext = context.operation();
            if (operationContext == null) return;

            var operandContext = context.operand();
            string operation = GetOperationName(operationContext);
            int line = operationContext.Start.Line;
            int column = operationContext.Start.Column;
            int operandCount = operandContext != null ? operandContext.operandExpr().Length : 0;

            // Verificar instrucciones sin operandos
            if (NoOperandInstructions.Contains(operation))
            {
                if (operandCount > 0)
                {
                    _errors.Add(new SICXEError(line, column,
                        $"La instrucción '{operation}' no debe tener operandos",
                        SICXEErrorType.Semantico));
                }
            }
            // Verificar instrucciones que requieren 2 registros
            else if (TwoRegisterInstructions.Contains(operation))
            {
                if (operandCount != 2)
                {
                    _errors.Add(new SICXEError(line, column,
                        $"La instrucción '{operation}' requiere exactamente 2 registros (tiene {operandCount})",
                        SICXEErrorType.Semantico));
                }
                else if (operandContext != null)
                {
                    ValidateRegisterOperands(operandContext, operation, 2);
                }
            }
            // Verificar instrucciones que requieren 1 registro
            else if (OneRegisterInstructions.Contains(operation))
            {
                if (operandCount != 1)
                {
                    _errors.Add(new SICXEError(line, column,
                        $"La instrucción '{operation}' requiere exactamente 1 registro (tiene {operandCount})",
                        SICXEErrorType.Semantico));
                }
                else if (operandContext != null)
                {
                    ValidateRegisterOperands(operandContext, operation, 1);
                }
            }
            // Verificar instrucciones registro + número
            else if (RegisterNumberInstructions.Contains(operation))
            {
                if (operandCount != 2)
                {
                    _errors.Add(new SICXEError(line, column,
                        $"La instrucción '{operation}' requiere registro y número (tiene {operandCount} operandos)",
                        SICXEErrorType.Semantico));
                }
            }
            // Verificar directivas que requieren operando
            else if (RequiredOperandDirectives.Contains(operation))
            {
                if (operandCount == 0)
                {
                    _errors.Add(new SICXEError(line, column,
                        $"La directiva '{operation}' requiere al menos un operando",
                        SICXEErrorType.Semantico));
                }
                
                // Validaciones específicas por directiva
                if (operandContext != null)
                    ValidateDirectiveOperands(operation, operandContext, line, column);
            }
            // Verificar directivas sin operando
            else if (NoOperandDirectives.Contains(operation))
            {
                if (operandCount > 0)
                {
                    _errors.Add(new SICXEError(line, column,
                        $"La directiva '{operation}' no debe tener operandos",
                        SICXEErrorType.Semantico));
                }
            }
            // Instrucciones de formato 3/4 que requieren dirección/operando
            else
            {
                // La mayoría de instrucciones formato 3/4 requieren operando
                if (operandCount == 0 && !operation.Equals("RSUB", StringComparison.OrdinalIgnoreCase))
                {
                    // Algunas instrucciones pueden omitir operando en ciertos casos
                    // pero generalmente requieren uno
                }
            }
        }

        /// <summary>
        /// Obtiene el nombre de la operación desde el contexto
        /// </summary>
        private string GetOperationName(SICXEParser.OperationContext operationContext)
        {
            var instructionContext = operationContext.instruction();
            if (instructionContext != null)
            {
                return instructionContext.GetText().ToUpper();
            }
            var directiveContext = operationContext.directive();
            if (directiveContext != null)
            {
                return directiveContext.GetText().ToUpper();
            }
            return operationContext.GetText().TrimStart('+').ToUpper();
        }

        /// <summary>
        /// Valida que los operandos sean registros válidos
        /// </summary>
        private void ValidateRegisterOperands(SICXEParser.OperandContext operandContext, string operation, int expectedCount)
        {
            if (operandContext == null) return;

            var operands = operandContext.operandExpr();
            for (int i = 0; i < Math.Min(operands.Length, expectedCount); i++)
            {
                var operand = operands[i];
                var operandValue = operand.operandValue();
                if (operandValue != null)
                {
                    string text = operandValue.GetText();
                    if (!ValidRegisters.Contains(text))
                    {
                        _errors.Add(new SICXEError(operand.Start.Line, operand.Start.Column,
                            $"'{text}' no es un registro válido para la instrucción '{operation}'",
                            SICXEErrorType.Semantico));
                    }
                }
            }
        }

        /// <summary>
        /// Validaciones específicas para directivas
        /// </summary>
        private void ValidateDirectiveOperands(string directive, SICXEParser.OperandContext operandContext, int line, int column)
        {
            if (operandContext == null) return;

            var operands = operandContext.operandExpr();
            if (operands.Length == 0) return;

            switch (directive.ToUpper())
            {
                case "BYTE":
                    // BYTE debe tener constante hexadecimal o de caracteres
                    var byteOperand = operands[0].GetText();
                    if (!byteOperand.StartsWith("X'", StringComparison.OrdinalIgnoreCase) &&
                        !byteOperand.StartsWith("C'", StringComparison.OrdinalIgnoreCase))
                    {
                        _errors.Add(new SICXEError(line, column,
                            $"BYTE requiere constante hexadecimal (X'..') o de caracteres (C'..')",
                            SICXEErrorType.Semantico));
                    }
                    break;

                case "WORD":
                case "RESB":
                case "RESW":
                    // Deben tener valor numérico o expresión
                    var value = operands[0].GetText();
                    // Verificación básica
                    break;

                case "START":
                    // START debe tener una dirección hexadecimal o 0
                    break;
            }
        }

        /// <summary>
        /// Genera el reporte de análisis
        /// </summary>
        public string GenerateReport(string fileName, bool verbose = false)
        {
            var sb = new StringBuilder();
            sb.AppendLine("═══════════════════════════════════════════════════════════════════");
            sb.AppendLine("                    REPORTE DE ANÁLISIS SIC/XE                      ");
            sb.AppendLine("═══════════════════════════════════════════════════════════════════");
            sb.AppendLine($"Archivo: {fileName}");
            sb.AppendLine($"Fecha: {DateTime.Now:dd/MM/yyyy HH:mm:ss}");
            sb.AppendLine("───────────────────────────────────────────────────────────────────");

            // Reporte de tokens
            if (verbose)
            {
                sb.AppendLine();
                sb.AppendLine("TOKENS RECONOCIDOS:");
                sb.AppendLine("───────────────────────────────────────────────────────────────────");
                sb.AppendLine($"{"Línea",-8}{"Columna",-10}{"Token",-20}{"Tipo",-20}");
                sb.AppendLine("───────────────────────────────────────────────────────────────────");
                
                foreach (var token in _tokens.Where(t => t.TypeName != "NEWLINE" && t.TypeName != "WS"))
                {
                    sb.AppendLine($"{token.Line,-8}{token.Column,-10}{token.Text,-20}{token.TypeName,-20}");
                }
            }

            // Estadísticas de tokens
            sb.AppendLine();
            sb.AppendLine("RESUMEN DE TOKENS:");
            sb.AppendLine("───────────────────────────────────────────────────────────────────");
            var tokenGroups = _tokens
                .Where(t => t.TypeName != "NEWLINE" && t.TypeName != "WS")
                .GroupBy(t => t.TypeName)
                .OrderByDescending(g => g.Count());
            
            foreach (var group in tokenGroups.Take(10))
            {
                sb.AppendLine($"  {group.Key}: {group.Count()}");
            }
            sb.AppendLine($"  Total tokens: {_tokens.Count(t => t.TypeName != "NEWLINE" && t.TypeName != "WS")}");

            // Etiquetas definidas
            sb.AppendLine();
            sb.AppendLine("ETIQUETAS DEFINIDAS:");
            sb.AppendLine("───────────────────────────────────────────────────────────────────");
            if (_definedLabels.Count > 0)
            {
                foreach (var label in _definedLabels.OrderBy(l => l))
                {
                    sb.AppendLine($"  • {label}");
                }
                sb.AppendLine($"  Total etiquetas: {_definedLabels.Count}");
            }
            else
            {
                sb.AppendLine("  (No se encontraron etiquetas)");
            }

            // Errores
            sb.AppendLine();
            sb.AppendLine("ERRORES ENCONTRADOS:");
            sb.AppendLine("───────────────────────────────────────────────────────────────────");
            if (_errors.Count > 0)
            {
                foreach (var error in _errors.OrderBy(e => e.Line).ThenBy(e => e.Column))
                {
                    sb.AppendLine($"  ✗ {error}");
                }
                sb.AppendLine();
                sb.AppendLine($"  Total errores: {_errors.Count}");
            }
            else
            {
                sb.AppendLine("  ✓ No se encontraron errores semánticos");
            }

            sb.AppendLine();
            sb.AppendLine("═══════════════════════════════════════════════════════════════════");
            if (_errors.Count == 0)
            {
                sb.AppendLine("        ✓ PROGRAMA VÁLIDO - Análisis completado sin errores         ");
            }
            else
            {
                sb.AppendLine($"        ✗ PROGRAMA CON ERRORES - Se encontraron {_errors.Count} error(es)       ");
            }
            sb.AppendLine("═══════════════════════════════════════════════════════════════════");

            return sb.ToString();
        }

        /// <summary>
        /// Agrega errores externos (léxicos/sintácticos)
        /// </summary>
        public void AddExternalErrors(IEnumerable<SICXEError> errors)
        {
            _errors.AddRange(errors);
        }
    }

    /// <summary>
    /// Información de un token para el reporte
    /// </summary>
    public class TokenInfo
    {
        public int Line { get; }
        public int Column { get; }
        public string Text { get; }
        public string TypeName { get; }
        public int TypeId { get; }

        public TokenInfo(int line, int column, string text, string typeName, int typeId)
        {
            Line = line;
            Column = column;
            Text = text;
            TypeName = typeName;
            TypeId = typeId;
        }
    }
}
